1. Приведите 2 примера кода: первый без параметризованного типа;  
второй - этот же код с параметризованным типом, иллюстрирующий преимущество данного варианта.  
**Ответ.**  
1 Пример 
```java
public static void main(String[] args) {
        List animals =new ArrayList();
        animals.add("cat");
        animals.add("dog");
        animals.add("frog");

        String animal = (String) animals.get(1);
        System.out.println(animal);
        }
```
2 Пример 
```java
public static void main(String[] args) {
        List<String> animals =new ArrayList();
        animals.add("cat");
        animals.add("dog");
        animals.add("frog");

        String animal = animals.get(1);
        System.out.println(animal);
    }
```

**Источник.** https://www.youtube.com/watch?v=iQIR2Zgb93k3

2. Какие типы данных запрещены в качестве параметров классов?  
**Ответ.**  
При использовании обобщенных классов параметр типа должен быть только ссылочного типа. 
При использовании обобщенного класса запрещается использовать базовые типы (int, char, double и т.д.) в качестве аргумента типа.  
**Источник.** https://www.bestprog.net/ru/2020/08/30/java-generalizations-parameterized-types-generic-classes-interfaces-methods-ru/#q04    
   
   
3. Дан код:
```java
class Gen <T1, T2 extends Number, T3 extends Object> { … }
```
Какие типы можно использовать в качестве аргументов T1, T2, T3?  
**Ответ.**  
Параметр типа Т1,Т3 может обозначать любой класс, следовательно можно использовать любой тип подкласса T1   
В качестве типа Т2 допустимо использовать только подклассы класса ``Number``  
**Источник.** И. Блинов. Глава 3, стр. 68.


4. Дан код:
```java
class Gen1 <T> { … }
class Gen2 <T extends Object> { … }
class Runner {
private final static Gen1<Object> g11 = new Gen1<>();
private final static Gen1 g12 = new Gen1();
private final static Gen2<Object> g21 = new Gen2<>();
private final static Gen2 g22 = new Gen2();
...
}
```
В чем различие объявления классов ``Gen1`` и ``Gen2``?  
Есть ли преимущество в объявлении ``g11`` по сравнению с ``g12``? Обоснуйте ответ.  
Есть ли преимущество в объявлении ``g21`` по сравнению с ``g12``? Обоснуйте ответ.  
В каком случае используется второй способ (``g12``, ``g22``)?  
**Ответ.**  
**Источник.**

5. Дан код:
```java
class SubInfo extends Info { … }
class Gen1 <T> { … }
class Gen2 <T extends Info> { … }
```
1. Является ли декларация`` Gen1<Info>`` подклассом ``Gen2<Info>``?  
2. Является ли декларация ``Gen1<SubInfo>`` подклассом ``Gen1<Info>``?  
3. Является ли декларация ``Gen2<SubInfo>`` подклассом ``Gen2<Info>``?  
**Ответ.**  
 1.Нет  
 2.Да  
 3.Нет     
**Источник.**  


6. Почему нельзя вызвать конструктор ``generic``-типа?  
**Ответ.**  
Компилятор не знает, какой конструктор может быть вызван и какой объем памяти должен быть выделен при создании объекта.   
**Источник.** И. Блинов. Глава 3, стр. 72.


7. Почему нельзя создать ``generic``-поле?  
**Ответ.**  
Компилятор не знает, какой конструктор может быть вызван и какой объем памяти должен быть выделен при создании объекта.  
**Источник.** И. Блинов. Глава 3, стр. 72.


8. Почему статический метод не может иметь ``generic``-параметр?  
**Ответ.**  
Компилятор не знает, какой конструктор может быть вызван и какой объем памяти должен быть выделен при создании объекта.  
**Источник.** И. Блинов. Глава 3, стр. 72. 
   

9. Предложите более эффективную запись данного кода:
```java
<T> void make1(Gen <T extends Object> gen) { … }
<T, S extends T> void make2(Info<T> info1, Info<S> info2) { … }
```
**Ответ.**  
**Источник.**  
   
10. Дан код:
```java
class Info {
public <T1> Info() { … }
public <T2> Info(T2 t2) { … }
public <T1> void make1(T1 t1) { … }
public <T3> void make2() { … }
}
```
Создайте какой-либо экземпляр класса ``Info``
1. конструктором без аргументов,  
2. конструктором с аргументом.  
Синтаксически правильно вызовите методы ``make1()`` и ``make2()``.  
**Ответ.**  
**Источник.**  
    

11. Поясните данный код:
```java
static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll)
```
**Ответ.**  
Возвращает максимальный элемент данной коллекции в соответствии с естественным порядком ее элементов. Все элементы коллекции должны реализовывать интерфейс Comparable. Кроме того, все элементы в коллекции должны быть взаимно сравнимы (то есть e1.compareTo(e2) не должен вызывать исключение ClassCastException для любых элементов e1 и e2 в коллекции).
**Источник.**https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html 